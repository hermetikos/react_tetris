{"ast":null,"code":"import _toConsumableArray from\"/home/stan/react-tetris/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/home/stan/react-tetris/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/home/stan/react-tetris/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";// React Hooks should begin with 'use'\n// we only need useState from react\nimport{useState,useCallback,cloneElement}from'react';import{checkCollision,STAGE_WIDTH}from'../gameHelpers';import{TETROMINOS,randomTetromino}from\"../tetrominos\";export var usePlayer=function usePlayer(){// use state returns an array with two values\n// (we use ES6 destructuring to access these two vals)\n// the first is effectively a getter, a variable which can be used\n//  to read state\n// the second value is a setter function\n// note we can set default state by passing a value to useState\nvar _useState=useState({pos:{x:0,y:0},tetromino:TETROMINOS[0].shape,collided:false}),_useState2=_slicedToArray(_useState,2),player=_useState2[0],setPlayer=_useState2[1];// performs a rotation on a matrix\nvar rotate=function rotate(matrix,dir){// make the rows into columns (transpose)\nvar rotatedTetromino=matrix.map(function(_,index){return matrix.map(function(col){return col[index];});});// then reverse each row (if applicable)\n// this will give the rotated matrix\nif(dir>0)return rotatedTetromino.map(function(row){return row.reverse();});return rotatedTetromino;};// performs a rotation of a tetromino\n// and handles any collision that occurs\nvar playerRotate=function playerRotate(stage,dir){// const copiedTetromino = { ...player };\n// const copiedTetromino = JSON.parse(JSON.stringify(player));\nvar copiedTetromino=_objectSpread(_objectSpread({},player),{},{pos:_objectSpread({},player.pos),tetromino:_toConsumableArray(player.tetromino)});copiedTetromino.tetromino=rotate(copiedTetromino.tetromino,dir);var position=copiedTetromino.pos.x;var offset=1;// this works by \"projecting\" the current piece left and right slightly\n// if the current piece can't fit to the left or right,\n// we shouldn't allow for rotation\nwhile(checkCollision(copiedTetromino,stage,{x:0,y:0})){// initially, we move the piece right by 1\ncopiedTetromino.pos.x+=offset;// basically, this routine shifts the tetromino back and forth\n// but if we are offset beyond the size of the teromino\n// and we are still colliding with something,\n// we can't rotate the piece in the current position\n// because there simply isn't room.\noffset=-(offset+(offset>0?1:-1));if(offset>copiedTetromino.tetromino[0].length){// rotate(copiedTetromino.tetromino, -dir);\n// copiedTetromino.pos.x = position;\nreturn;}}setPlayer(copiedTetromino);};// a helper function that updates player position\n// it usese the setter function generated above\nvar updatePlayerPos=function updatePlayerPos(_ref){var x=_ref.x,y=_ref.y,collided=_ref.collided;// pass an arrow function\n// note that a callback is passed\n// you can pass a callback if your new state depends on the old\nsetPlayer(function(prev){return _objectSpread(_objectSpread({},prev),{},{pos:{x:prev.pos.x+=x,y:prev.pos.y+=y},collided:collided});});};// useCallback returns a memoized callback\n// that is, the exact function generated by this hook\n// is preserved between calls of this custom hook\n// (all other callbacks will be recreated each hook call)\n// because it is memoized, each unique input returns\n// the exact same function\n// the inputs are determined by the array given as the second arg\n// so in this case, we just want to create this function once\nvar resetPlayer=useCallback(function(){setPlayer({pos:{x:STAGE_WIDTH/2-2,y:0},tetromino:randomTetromino().shape,collided:false});},[]);// we will import this hook into the tetris component\n// by returning the player setter, we can then use the return\n// value to query the player state in tetris component\nreturn[player,updatePlayerPos,resetPlayer,playerRotate];};","map":{"version":3,"sources":["/home/stan/react-tetris/app/src/hooks/usePlayer.js"],"names":["useState","useCallback","cloneElement","checkCollision","STAGE_WIDTH","TETROMINOS","randomTetromino","usePlayer","pos","x","y","tetromino","shape","collided","player","setPlayer","rotate","matrix","dir","rotatedTetromino","map","_","index","col","row","reverse","playerRotate","stage","copiedTetromino","position","offset","length","updatePlayerPos","prev","resetPlayer"],"mappings":"6bAAA;AAEA;AACA,OAASA,QAAT,CAAmBC,WAAnB,CAAgCC,YAAhC,KAAoD,OAApD,CACA,OAASC,cAAT,CAAyBC,WAAzB,KAA4C,gBAA5C,CAEA,OAASC,UAAT,CAAqBC,eAArB,KAA4C,eAA5C,CAEA,MAAO,IAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,EAAM,CAC3B;AACA;AACA;AACA;AACA;AACA;AAN2B,cAOCP,QAAQ,CAAC,CACjCQ,GAAG,CAAE,CAAEC,CAAC,CAAE,CAAL,CAAQC,CAAC,CAAE,CAAX,CAD4B,CAEjCC,SAAS,CAAEN,UAAU,CAAC,CAAD,CAAV,CAAcO,KAFQ,CAGjCC,QAAQ,CAAE,KAHuB,CAAD,CAPT,wCAOpBC,MAPoB,eAOZC,SAPY,eAa3B;AACA,GAAMC,CAAAA,MAAM,CAAG,QAATA,CAAAA,MAAS,CAACC,MAAD,CAASC,GAAT,CAAiB,CAC5B;AACA,GAAMC,CAAAA,gBAAgB,CAAGF,MAAM,CAACG,GAAP,CAAW,SAACC,CAAD,CAAIC,KAAJ,QAChCL,CAAAA,MAAM,CAACG,GAAP,CAAW,SAAAG,GAAG,QAAIA,CAAAA,GAAG,CAACD,KAAD,CAAP,EAAd,CADgC,EAAX,CAAzB,CAGA;AACA;AACA,GAAIJ,GAAG,CAAG,CAAV,CAAa,MAAOC,CAAAA,gBAAgB,CAACC,GAAjB,CAAqB,SAAAI,GAAG,QAAIA,CAAAA,GAAG,CAACC,OAAJ,EAAJ,EAAxB,CAAP,CACb,MAAON,CAAAA,gBAAP,CACH,CATD,CAWA;AACA;AACA,GAAMO,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAACC,KAAD,CAAQT,GAAR,CAAgB,CACjC;AACA;AACA,GAAMU,CAAAA,eAAe,gCAAQd,MAAR,MAAgBN,GAAG,kBAAOM,MAAM,CAACN,GAAd,CAAnB,CAAuCG,SAAS,oBAAMG,MAAM,CAACH,SAAb,CAAhD,EAArB,CACAiB,eAAe,CAACjB,SAAhB,CAA4BK,MAAM,CAACY,eAAe,CAACjB,SAAjB,CAA4BO,GAA5B,CAAlC,CAEA,GAAMW,CAAAA,QAAQ,CAAGD,eAAe,CAACpB,GAAhB,CAAoBC,CAArC,CACA,GAAIqB,CAAAA,MAAM,CAAG,CAAb,CACA;AACA;AACA;AACA,MAAM3B,cAAc,CAACyB,eAAD,CAAkBD,KAAlB,CAAyB,CAAElB,CAAC,CAAE,CAAL,CAAQC,CAAC,CAAE,CAAX,CAAzB,CAApB,CAA6D,CACzD;AACAkB,eAAe,CAACpB,GAAhB,CAAoBC,CAApB,EAAyBqB,MAAzB,CAEA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAAG,EAAEA,MAAM,EAAIA,MAAM,CAAG,CAAT,CAAa,CAAb,CAAiB,CAAC,CAAtB,CAAR,CAAT,CAEA,GAAIA,MAAM,CAAGF,eAAe,CAACjB,SAAhB,CAA0B,CAA1B,EAA6BoB,MAA1C,CAAkD,CAC9C;AACA;AAEA,OACH,CACJ,CAEDhB,SAAS,CAACa,eAAD,CAAT,CACH,CA/BD,CAiCA;AACA;AACA,GAAMI,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,MAAsB,IAApBvB,CAAAA,CAAoB,MAApBA,CAAoB,CAAjBC,CAAiB,MAAjBA,CAAiB,CAAdG,QAAc,MAAdA,QAAc,CAC1C;AACA;AACA;AACAE,SAAS,CAAC,SAAAkB,IAAI,wCACPA,IADO,MAEVzB,GAAG,CAAE,CAAEC,CAAC,CAAGwB,IAAI,CAACzB,GAAL,CAASC,CAAT,EAAcA,CAApB,CAAwBC,CAAC,CAAEuB,IAAI,CAACzB,GAAL,CAASE,CAAT,EAAcA,CAAzC,CAFK,CAGVG,QAAQ,CAARA,QAHU,IAAL,CAAT,CAKH,CATD,CAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAMqB,CAAAA,WAAW,CAAGjC,WAAW,CAAC,UAAM,CAClCc,SAAS,CAAC,CACNP,GAAG,CAAE,CAAEC,CAAC,CAAEL,WAAW,CAAG,CAAd,CAAkB,CAAvB,CAA0BM,CAAC,CAAE,CAA7B,CADC,CAENC,SAAS,CAAEL,eAAe,GAAGM,KAFvB,CAGNC,QAAQ,CAAE,KAHJ,CAAD,CAAT,CAKH,CAN8B,CAM5B,EAN4B,CAA/B,CAQA;AACA;AACA;AACA,MAAO,CAACC,MAAD,CAASkB,eAAT,CAA0BE,WAA1B,CAAuCR,YAAvC,CAAP,CACH,CA7FM","sourcesContent":["// React Hooks should begin with 'use'\n\n// we only need useState from react\nimport { useState, useCallback, cloneElement } from 'react';\nimport { checkCollision, STAGE_WIDTH } from '../gameHelpers';\n\nimport { TETROMINOS, randomTetromino } from \"../tetrominos\";\n\nexport const usePlayer = () => {\n    // use state returns an array with two values\n    // (we use ES6 destructuring to access these two vals)\n    // the first is effectively a getter, a variable which can be used\n    //  to read state\n    // the second value is a setter function\n    // note we can set default state by passing a value to useState\n    const [player, setPlayer] = useState({\n        pos: { x: 0, y: 0},\n        tetromino: TETROMINOS[0].shape,\n        collided: false\n    });\n\n    // performs a rotation on a matrix\n    const rotate = (matrix, dir) => {\n        // make the rows into columns (transpose)\n        const rotatedTetromino = matrix.map((_, index) => \n            matrix.map(col => col[index]),\n        )\n        // then reverse each row (if applicable)\n        // this will give the rotated matrix\n        if (dir > 0) return rotatedTetromino.map(row => row.reverse());\n        return rotatedTetromino;\n    }\n\n    // performs a rotation of a tetromino\n    // and handles any collision that occurs\n    const playerRotate = (stage, dir) => {\n        // const copiedTetromino = { ...player };\n        // const copiedTetromino = JSON.parse(JSON.stringify(player));\n        const copiedTetromino = { ...player, pos: { ...player.pos}, tetromino: [...player.tetromino] }\n        copiedTetromino.tetromino = rotate(copiedTetromino.tetromino, dir);\n\n        const position = copiedTetromino.pos.x;        \n        let offset = 1;\n        // this works by \"projecting\" the current piece left and right slightly\n        // if the current piece can't fit to the left or right,\n        // we shouldn't allow for rotation\n        while(checkCollision(copiedTetromino, stage, { x: 0, y: 0})) {\n            // initially, we move the piece right by 1\n            copiedTetromino.pos.x += offset;\n\n            // basically, this routine shifts the tetromino back and forth\n            // but if we are offset beyond the size of the teromino\n            // and we are still colliding with something,\n            // we can't rotate the piece in the current position\n            // because there simply isn't room.\n            offset = -(offset + (offset > 0 ? 1 : -1));\n\n            if (offset > copiedTetromino.tetromino[0].length) {\n                // rotate(copiedTetromino.tetromino, -dir);\n                // copiedTetromino.pos.x = position;\n\n                return;\n            }\n        }\n\n        setPlayer(copiedTetromino);\n    }\n\n    // a helper function that updates player position\n    // it usese the setter function generated above\n    const updatePlayerPos = ({x, y, collided}) => {\n        // pass an arrow function\n        // note that a callback is passed\n        // you can pass a callback if your new state depends on the old\n        setPlayer(prev => ({\n            ...prev,\n            pos: { x: (prev.pos.x += x), y: prev.pos.y += y},\n            collided\n        }));\n    }\n\n    // useCallback returns a memoized callback\n    // that is, the exact function generated by this hook\n    // is preserved between calls of this custom hook\n    // (all other callbacks will be recreated each hook call)\n    // because it is memoized, each unique input returns\n    // the exact same function\n    // the inputs are determined by the array given as the second arg\n    // so in this case, we just want to create this function once\n    const resetPlayer = useCallback(() => {\n        setPlayer({\n            pos: { x: STAGE_WIDTH / 2 - 2, y: 0 },\n            tetromino: randomTetromino().shape,\n            collided: false\n        })\n    }, []);\n\n    // we will import this hook into the tetris component\n    // by returning the player setter, we can then use the return\n    // value to query the player state in tetris component\n    return [player, updatePlayerPos, resetPlayer, playerRotate];\n}\n"]},"metadata":{},"sourceType":"module"}