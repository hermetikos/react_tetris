{"ast":null,"code":"export var STAGE_WIDTH=12;export var STAGE_HEIGHT=20;export var createStage=function createStage(){return Array.from(Array(STAGE_HEIGHT),function(){return new Array(STAGE_WIDTH).fill([0,'clear']);});};// this creates the initial game field\n// each cell in the field contains a tuple\n// the first value represents the tetrimino shape occupying the cell\n// 0 means nothing in the cell\n// the second tuple value tells whether the cell needs to be emptied\n// because a line is full\n// or if it can go untouched\n// the JS object renames the parameters within the function\nexport var checkCollision=function checkCollision(player,stage,_ref){var moveX=_ref.x,moveY=_ref.y;for(var y=0;y<player.tetromino.length;y+=1){for(var x=0;x<player.tetromino[y].length;x+=1){// 1. check that we're in a non-empty cell\nif(player.tetromino[y][x]!==0){console.log(\"new x: \".concat(x+player.pos.x+moveX,\" new y: \").concat(y+player.pos.y+moveY));var newX=x+player.pos.x+moveX;var newY=y+player.pos.y+moveY;if(// 2. check the new position is within the game area's height\n!stage[newY]||// newY >= 0 && newY < stage.length &&\n// 3. check we're within the game area's width\n!stage[newY][newX]||// newX >= 0 && newX < stage[0].length &&\n// 4. check we are not colliding with a placed tetromino\n// this is done by checking if the cell is NOT set to 'clear'\nstage[newY][newX][1]!=='clear'){return true;}}}}};","map":{"version":3,"sources":["/home/stan/react-tetris/app/src/gameHelpers.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","moveX","x","moveY","y","tetromino","length","console","log","pos","newX","newY"],"mappings":"AAAA,MAAO,IAAMA,CAAAA,WAAW,CAAG,EAApB,CACP,MAAO,IAAMC,CAAAA,YAAY,CAAG,EAArB,CAEP,MAAO,IAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,SACvBC,CAAAA,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,CAAgC,iBAC5B,IAAIE,CAAAA,KAAJ,CAAUH,WAAV,EAAuBK,IAAvB,CAA4B,CAAC,CAAD,CAAI,OAAJ,CAA5B,CAD4B,EAAhC,CADuB,EAApB,CAIP;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,MAAO,IAAMC,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,MAAD,CAASC,KAAT,MAA0C,IAArBC,CAAAA,KAAqB,MAAxBC,CAAwB,CAAXC,KAAW,MAAdC,CAAc,CACpE,IAAK,GAAIA,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGL,MAAM,CAACM,SAAP,CAAiBC,MAArC,CAA6CF,CAAC,EAAI,CAAlD,CAAqD,CACjD,IAAK,GAAIF,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGH,MAAM,CAACM,SAAP,CAAiBD,CAAjB,EAAoBE,MAAxC,CAAgDJ,CAAC,EAAI,CAArD,CAAwD,CACpD;AACA,GAAIH,MAAM,CAACM,SAAP,CAAiBD,CAAjB,EAAoBF,CAApB,IAA2B,CAA/B,CAAkC,CAC9BK,OAAO,CAACC,GAAR,kBAAsBN,CAAC,CAAGH,MAAM,CAACU,GAAP,CAAWP,CAAf,CAAmBD,KAAzC,oBAAyDG,CAAC,CAAGL,MAAM,CAACU,GAAP,CAAWL,CAAf,CAAmBD,KAA5E,GACA,GAAMO,CAAAA,IAAI,CAAGR,CAAC,CAAGH,MAAM,CAACU,GAAP,CAAWP,CAAf,CAAmBD,KAAhC,CACA,GAAMU,CAAAA,IAAI,CAAGP,CAAC,CAAGL,MAAM,CAACU,GAAP,CAAWL,CAAf,CAAmBD,KAAhC,CACA,GACI;AACA,CAACH,KAAK,CAACW,IAAD,CAAN,EACA;AACA;AACA,CAACX,KAAK,CAACW,IAAD,CAAL,CAAYD,IAAZ,CAHD,EAIA;AACA;AACA;AACAV,KAAK,CAACW,IAAD,CAAL,CAAYD,IAAZ,EAAkB,CAAlB,IAAyB,OAT7B,CAUE,CACE,MAAO,KAAP,CACH,CACJ,CACJ,CACJ,CACJ,CAxBM","sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\n\nexport const createStage = () => \n    Array.from(Array(STAGE_HEIGHT), () =>\n        new Array(STAGE_WIDTH).fill([0, 'clear'])\n    );\n// this creates the initial game field\n// each cell in the field contains a tuple\n// the first value represents the tetrimino shape occupying the cell\n// 0 means nothing in the cell\n// the second tuple value tells whether the cell needs to be emptied\n// because a line is full\n// or if it can go untouched\n\n// the JS object renames the parameters within the function\nexport const checkCollision = (player, stage, { x: moveX, y: moveY}) => {\n    for (let y = 0; y < player.tetromino.length; y += 1) {\n        for (let x = 0; x < player.tetromino[y].length; x += 1) {\n            // 1. check that we're in a non-empty cell\n            if (player.tetromino[y][x] !== 0) {\n                console.log(`new x: ${x + player.pos.x + moveX} new y: ${y + player.pos.y + moveY}`)\n                const newX = x + player.pos.x + moveX;\n                const newY = y + player.pos.y + moveY;\n                if(\n                    // 2. check the new position is within the game area's height\n                    !stage[newY] || \n                    // newY >= 0 && newY < stage.length &&\n                    // 3. check we're within the game area's width\n                    !stage[newY][newX] ||\n                    // newX >= 0 && newX < stage[0].length &&\n                    // 4. check we are not colliding with a placed tetromino\n                    // this is done by checking if the cell is NOT set to 'clear'\n                    stage[newY][newX][1] !== 'clear'\n                ) {\n                    return true;\n                }\n            }\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}