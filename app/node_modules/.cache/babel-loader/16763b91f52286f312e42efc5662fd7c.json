{"ast":null,"code":"import _slicedToArray from\"/home/stan/react-tetris/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from\"react\";import{createStage}from\"../gameHelpers\";export var useStage=function useStage(player,resetPlayer){var _useState=useState(createStage()),_useState2=_slicedToArray(_useState,2),stage=_useState2[0],setStage=_useState2[1];// used to count number of cleared rows (used to compute score)\nvar _useState3=useState(0),_useState4=_slicedToArray(_useState3,2),rowsCleared=_useState4[0],setRowsCleared=_useState4[1];// useEffect is used to allow you to make changes due to side effects\n// basically, hooks try to avoid side effects, but it isn't quite possible\n// to eliminate them\n// useEffect takes a callback and a list of dependancies\n// if you omit the dependancies, this callback will fire after every render\n// otherwise, it will fire after a render IF a dependancy changes\nuseEffect(function(){setRowsCleared(0);// this function clears out complete rows\nvar sweepRows=function sweepRows(newStage){return(// we use the reduce method\nnewStage.reduce(function(acc,row){// a row in the stage is filled if all values are greater than 0\n// so we search the row for 0\n// if there are no 0s, clear the cell\nif(row.findIndex(function(cell){return cell[0]===0;})===-1){// also increment the number of rows we've cleared\nsetRowsCleared(function(prev){return prev+1;});// here we create a new, empty row\n// which we use unshift to add it to the top of the stage\nacc.unshift(new Array(newStage[0].length).fill([0,'clear']));return acc;}// if the row isn't filled, just return the current row\nacc.push(row);return acc;},[]));};var updateStage=function updateStage(prevStage){// first we clear the stage so we can rewrite new data to it\nvar newStage=prevStage.map(function(row){return(// if the cell is marked as clear, we need to clear it\n// this is done by putting 0, the 'no tetromino' marker\n// otherwise, just replace it with the same cell value\nrow.map(function(cell){return cell[1]==='clear'?[0,'clear']:cell;}));});// then we draw the tetromino\n// player basically refers to the current falling game piece\n// so this splices in the current falling tetrimino into the grid\n// in the appropriate position\nplayer.tetromino.forEach(function(row,y){row.forEach(function(value,x){// we skip values that are 0, which are blank\n// values in the tetromino\nif(value!==0){newStage[y+player.pos.y][x+player.pos.x]=[value,\"\".concat(player.collided?'merged':'clear')];}});});// do collision detection\n// if the current falling piece collided with something, \n// we should stop moving the current piece\n// and bring a new one to the top of the play field\nif(player.collided){resetPlayer();// additionally, now would be the time where we would check if\n// we need to clear rows\nreturn sweepRows(newStage);}return newStage;};// call the stage setter using the above instructions\nsetStage(function(prev){return updateStage(prev);});},[player,player.collided]);// this hook will allow us to both read and alter the stage state\n// so return both the getter and the setter\nreturn[stage,setStage,rowsCleared];};","map":{"version":3,"sources":["/home/stan/react-tetris/app/src/hooks/useStage.js"],"names":["useState","useEffect","createStage","useStage","player","resetPlayer","stage","setStage","rowsCleared","setRowsCleared","sweepRows","newStage","reduce","acc","row","findIndex","cell","prev","unshift","Array","length","fill","push","updateStage","prevStage","map","tetromino","forEach","y","value","x","pos","collided"],"mappings":"kJAAA,OAASA,QAAT,CAAmBC,SAAnB,KAAoC,OAApC,CAEA,OAASC,WAAT,KAA4B,gBAA5B,CAEA,MAAO,IAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAACC,MAAD,CAASC,WAAT,CAAyB,eACnBL,QAAQ,CAACE,WAAW,EAAZ,CADW,wCACtCI,KADsC,eAC/BC,QAD+B,eAE7C;AAF6C,eAGPP,QAAQ,CAAC,CAAD,CAHD,yCAGtCQ,WAHsC,eAGzBC,cAHyB,eAK7C;AACA;AACA;AACA;AACA;AACA;AACAR,SAAS,CAAC,UAAM,CACZQ,cAAc,CAAC,CAAD,CAAd,CAEA;AACA,GAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAAAC,QAAQ,QACtB;AACAA,QAAQ,CAACC,MAAT,CAAgB,SAACC,GAAD,CAAMC,GAAN,CAAc,CAC1B;AACA;AACA;AACA,GAAGA,GAAG,CAACC,SAAJ,CAAc,SAAAC,IAAI,QAAIA,CAAAA,IAAI,CAAC,CAAD,CAAJ,GAAY,CAAhB,EAAlB,IAAyC,CAAC,CAA7C,CAAgD,CAC5C;AACAP,cAAc,CAAC,SAAAQ,IAAI,QAAIA,CAAAA,IAAI,CAAG,CAAX,EAAL,CAAd,CACA;AACA;AACAJ,GAAG,CAACK,OAAJ,CAAY,GAAIC,CAAAA,KAAJ,CAAUR,QAAQ,CAAC,CAAD,CAAR,CAAYS,MAAtB,EAA8BC,IAA9B,CAAmC,CAAC,CAAD,CAAI,OAAJ,CAAnC,CAAZ,EACA,MAAOR,CAAAA,GAAP,CACH,CACD;AACAA,GAAG,CAACS,IAAJ,CAASR,GAAT,EACA,MAAOD,CAAAA,GAAP,CACP,CAfG,CAeD,EAfC,CAFsB,GAA1B,CAmBA,GAAMU,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAAAC,SAAS,CAAI,CAC7B;AACA,GAAMb,CAAAA,QAAQ,CAAGa,SAAS,CAACC,GAAV,CAAc,SAAAX,GAAG,QAC9B;AACA;AACA;AACAA,GAAG,CAACW,GAAJ,CAAQ,SAAAT,IAAI,QAAKA,CAAAA,IAAI,CAAC,CAAD,CAAJ,GAAY,OAAZ,CAAsB,CAAC,CAAD,CAAI,OAAJ,CAAtB,CAAqCA,IAA1C,EAAZ,CAJ8B,GAAjB,CAAjB,CAOA;AACA;AACA;AACA;AACAZ,MAAM,CAACsB,SAAP,CAAiBC,OAAjB,CAAyB,SAACb,GAAD,CAAMc,CAAN,CAAY,CACjCd,GAAG,CAACa,OAAJ,CAAY,SAACE,KAAD,CAAQC,CAAR,CAAc,CACtB;AACA;AACA,GAAGD,KAAK,GAAK,CAAb,CAAgB,CACZlB,QAAQ,CAACiB,CAAC,CAAGxB,MAAM,CAAC2B,GAAP,CAAWH,CAAhB,CAAR,CAA2BE,CAAC,CAAG1B,MAAM,CAAC2B,GAAP,CAAWD,CAA1C,EAA+C,CAC3CD,KAD2C,WAExCzB,MAAM,CAAC4B,QAAP,CAAkB,QAAlB,CAA6B,OAFW,EAA/C,CAIH,CACJ,CATD,EAUH,CAXD,EAaA;AACA;AACA;AACA;AACA,GAAI5B,MAAM,CAAC4B,QAAX,CAAqB,CACjB3B,WAAW,GACX;AACA;AACA,MAAOK,CAAAA,SAAS,CAACC,QAAD,CAAhB,CACH,CAED,MAAOA,CAAAA,QAAP,CACH,CAtCD,CAwCA;AACAJ,QAAQ,CAAC,SAAAU,IAAI,QAAIM,CAAAA,WAAW,CAACN,IAAD,CAAf,EAAL,CAAR,CACH,CAjEQ,CAiEN,CAACb,MAAD,CAASA,MAAM,CAAC4B,QAAhB,CAjEM,CAAT,CAmEA;AACA;AACA,MAAO,CAAC1B,KAAD,CAAQC,QAAR,CAAkBC,WAAlB,CAAP,CACH,CAjFM","sourcesContent":["import { useState, useEffect } from \"react\";\n\nimport { createStage } from \"../gameHelpers\";\n\nexport const useStage = (player, resetPlayer) => {\n    const [stage, setStage] = useState(createStage());\n    // used to count number of cleared rows (used to compute score)\n    const [rowsCleared, setRowsCleared] = useState(0);\n\n    // useEffect is used to allow you to make changes due to side effects\n    // basically, hooks try to avoid side effects, but it isn't quite possible\n    // to eliminate them\n    // useEffect takes a callback and a list of dependancies\n    // if you omit the dependancies, this callback will fire after every render\n    // otherwise, it will fire after a render IF a dependancy changes\n    useEffect(() => {\n        setRowsCleared(0);\n\n        // this function clears out complete rows\n        const sweepRows = newStage => \n            // we use the reduce method\n            newStage.reduce((acc, row) => {\n                // a row in the stage is filled if all values are greater than 0\n                // so we search the row for 0\n                // if there are no 0s, clear the cell\n                if(row.findIndex(cell => cell[0] === 0) === -1) {\n                    // also increment the number of rows we've cleared\n                    setRowsCleared(prev => prev + 1);\n                    // here we create a new, empty row\n                    // which we use unshift to add it to the top of the stage\n                    acc.unshift(new Array(newStage[0].length).fill([0, 'clear']));\n                    return acc;\n                }\n                // if the row isn't filled, just return the current row\n                acc.push(row);\n                return acc;\n        }, [])\n\n        const updateStage = prevStage => {\n            // first we clear the stage so we can rewrite new data to it\n            const newStage = prevStage.map(row =>\n                // if the cell is marked as clear, we need to clear it\n                // this is done by putting 0, the 'no tetromino' marker\n                // otherwise, just replace it with the same cell value\n                row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell))\n            );\n\n            // then we draw the tetromino\n            // player basically refers to the current falling game piece\n            // so this splices in the current falling tetrimino into the grid\n            // in the appropriate position\n            player.tetromino.forEach((row, y) => {\n                row.forEach((value, x) => {\n                    // we skip values that are 0, which are blank\n                    // values in the tetromino\n                    if(value !== 0) {\n                        newStage[y + player.pos.y][x + player.pos.x] = [\n                            value,\n                            `${player.collided ? 'merged' : 'clear'}`\n                        ]\n                    }\n                });\n            });\n\n            // do collision detection\n            // if the current falling piece collided with something, \n            // we should stop moving the current piece\n            // and bring a new one to the top of the play field\n            if (player.collided) {\n                resetPlayer();\n                // additionally, now would be the time where we would check if\n                // we need to clear rows\n                return sweepRows(newStage);\n            }\n\n            return newStage;\n        }\n\n        // call the stage setter using the above instructions\n        setStage(prev => updateStage(prev))\n    }, [player, player.collided]);\n\n    // this hook will allow us to both read and alter the stage state\n    // so return both the getter and the setter\n    return [stage, setStage, rowsCleared];\n}\n"]},"metadata":{},"sourceType":"module"}