{"version":3,"sources":["gameHelpers.js","tetrominos.js","components/styles/StyledCell.js","components/Cell.js","components/styles/StyledStage.js","components/Stage.js","components/styles/StyledDisplay.js","components/Display.js","components/styles/StyledStartButton.js","components/StartButton.js","img/bg.png","components/styles/StyledTetris.js","hooks/useStage.js","hooks/useGameStatus.js","components/Tetris.js","hooks/usePlayer.js","hooks/useInterval.js","App.js","reportWebVitals.js","index.js"],"names":["createStage","Array","from","fill","checkCollision","player","stage","moveX","x","moveY","y","tetromino","length","console","log","pos","newX","newY","TETROMINOS","0","shape","color","I","J","L","O","S","T","Z","randomTetromino","tetrominos","Math","floor","random","StyledCell","styled","div","props","type","Cell","StyledStage","height","width","Stage","map","row","cell","StyledDisplay","gameOver","Display","text","StyledStartButton","StartButton","callback","onClick","StyledTetrisWrapper","bgImage","StyledTetris","useStage","resetPlayer","useState","setStage","rowsCleared","setRowsCleared","useEffect","updateStage","prevStage","newStage","forEach","value","collided","reduce","acc","findIndex","prev","unshift","push","sweepRows","Tetris","dropTime","setDropTime","setGameOver","setPlayer","useCallback","STAGE_WIDTH","dir","copiedTetromino","matrix","rotatedTetromino","_","index","col","reverse","rotate","offset","usePlayer","updatePlayerPos","playerRotate","score","setScore","rows","setRows","level","setLevel","linePoints","calcScore","useGameStatus","movePlayer","drop","dropPlayer","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","role","tabIndex","onKeyDown","e","keyCode","move","onKeyUp","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b1d220a7.chunk.js","sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\n\nexport const createStage = () => \n    Array.from(Array(STAGE_HEIGHT), () =>\n        new Array(STAGE_WIDTH).fill([0, 'clear'])\n    );\n// this creates the initial game field\n// each cell in the field contains a tuple\n// the first value represents the tetrimino shape occupying the cell\n// 0 means nothing in the cell\n// the second tuple value tells whether the cell needs to be emptied\n// because a line is full\n// or if it can go untouched\n\n// the JS object renames the parameters within the function\nexport const checkCollision = (player, stage, { x: moveX, y: moveY}) => {\n    for (let y = 0; y < player.tetromino.length; y += 1) {\n        for (let x = 0; x < player.tetromino[y].length; x += 1) {\n            // 1. check that we're in a non-empty cell\n            if (player.tetromino[y][x] !== 0) {\n                console.log(`new x: ${x + player.pos.x + moveX} new y: ${y + player.pos.y + moveY}`)\n                const newX = x + player.pos.x + moveX;\n                const newY = y + player.pos.y + moveY;\n                if(\n                    // 2. check the new position is within the game area's height\n                    !stage[newY] || \n                    // newY >= 0 && newY < stage.length &&\n                    // 3. check we're within the game area's width\n                    !stage[newY][newX] ||\n                    // newX >= 0 && newX < stage[0].length &&\n                    // 4. check we are not colliding with a placed tetromino\n                    // this is done by checking if the cell is NOT set to 'clear'\n                    stage[newY][newX][1] !== 'clear'\n                ) {\n                    return true;\n                }\n            }\n        }\n    }\n}","export const TETROMINOS = {\n    0: { shape: [[0]], color: '0, 0, 0'},\n    I: { shape:\n        [\n            [0, 'I', 0, 0],\n            [0, 'I', 0, 0],\n            [0, 'I', 0, 0],\n            [0, 'I', 0, 0]\n        ],\n        color: '80, 227, 230'\n    },\n    J: { shape:\n        [\n            [0, 'J', 0],\n            [0, 'J', 0],\n            ['J', 'J', 0],\n        ],\n        color: '36, 95, 223'\n    },\n    L: { shape:\n        [\n            [0, 'L', 0],\n            [0, 'L', 0],\n            [0, 'L', 'L'],\n        ],\n        color: '223, 173, 36'\n    },\n    O: { shape:\n        [\n            ['O', 'O'],\n            ['O', 'O']\n        ],\n        color: '223, 217, 36'\n    },\n    S: { shape:\n        [\n            [0, 'S', 'S'],\n            ['S', 'S', 0],\n            [0, 0, 0],\n        ],\n        color: '48, 211, 56'\n    },\n    T: { shape:\n        [\n            [0, 0, 0],\n            ['T', 'T', 'T'],\n            [0, 'T', 0]\n        ],\n        color: '132, 61, 198'\n    },\n    Z: { shape:\n        [\n            ['Z', 'Z', 0],\n            [0, 'Z', 'Z'],\n            [0, 0, 0],\n        ],\n        color: '227, 78, 78'\n    },\n}\n\n// this function returns a random tetromino\nexport const randomTetromino = () => {\n    const tetrominos = 'IJLOSTZ';\n    const randomTetromino =\n        tetrominos[Math.floor(Math.random() * tetrominos.length)];\n    \n    return TETROMINOS[randomTetromino];\n}\n\n// export const TETROMINOS = {\n//     0: { shape: [[0]], color: '0, 0, 0' },\n//     I: {\n//       shape: [[0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0]],\n//       color: '80, 227, 230',\n//     },\n//     J: {\n//       shape: [[0, 'J', 0], [0, 'J', 0], ['J', 'J', 0]],\n//       color: '36, 95, 223',\n//     },\n//     L: {\n//       shape: [[0, 'L', 0], [0, 'L', 0], [0, 'L', 'L']],\n//       color: '223, 173, 36',\n//     },\n//     O: {\n//       shape: [['O', 'O'], ['O', 'O']],\n//       color: '223, 217, 36',\n//     },\n//     S: {\n//       shape: [[0, 'S', 'S'], ['S', 'S', 0], [0, 0, 0]],\n//       color: '48, 211, 56',\n//     },\n//     T: {\n//       shape: [[0, 0, 0], ['T', 'T', 'T'], [0, 'T', 0]],\n//       color: '132, 61, 198',\n//     },\n//     Z: {\n//       shape: [['Z', 'Z', 0], [0, 'Z', 'Z'], [0, 0, 0]],\n//       color: '227, 78, 78',\n//     },\n//   };\n  \n//   export const randomTetromino = () => {\n//     const tetrominos = 'IJLOSTZ';\n//     const randTetromino =\n//       tetrominos[Math.floor(Math.random() * tetrominos.length)];\n//     return TETROMINOS[randTetromino];\n//   };\n  ","import styled from 'styled-components';\n\nexport const StyledCell = styled.div`\n    width: auto;\n    background: rgba(${props => props.color}, 0.8);\n    border: ${props => (props.type === 0 ? '0px solid' : '4px solid')};\n    border-bottom-color: rgba(${props => props.color}, 0.1);\n    border-right-color: rgba(${props => props.color}, 1);\n    border-top-color: rgba(${props => props.color}, 1);\n    border-left-color: rgba(${props => props.color}, 0.3);\n`","import React from 'react';\n\nimport {TETROMINOS} from \"../tetrominos\";\n\nimport {StyledCell} from './styles/StyledCell';\n\n// cell is a simply a styled div element representing a cell in the grid\nconst Cell = ({ type }) => (\n    <StyledCell type={type} color={TETROMINOS[type].color} />\n)\n\nexport default Cell;\n","import styled from 'styled-components';\n\nexport const StyledStage = styled.div`\n    display: grid;\n    grid-template-rows: repeat(\n        ${props => props.height},\n        calc(25vw / ${props => props.width})\n    );\n    grid-template-columns: repeat(${props => props.width}, 1fr);\n    grid-gap: 1px;\n    border: 2px solid #333;\n    width: 100%;\n    max-width: 25vw;\n    background: #111;\n`;\n\n","import React from 'react';\n\nimport Cell from './Cell';\n\nimport { StyledStage } from \"./styles/StyledStage\";\n\n// Stage is the representation of the game field\nconst Stage = ({ stage }) => (\n    <StyledStage width={stage[0].length} height={stage.length}> \n        {stage.map(row => row.map((cell, x) => <Cell key={x} type={cell[0]}/>))}\n    </StyledStage>\n)\n\nexport default Stage;","import styled from 'styled-components';\n\nexport const StyledDisplay = styled.div`\n    box-sizing: border-box;\n    display: flex;\n    align-items: center;\n    margin: 0 0 20px 0;\n    padding: 20px;\n    border: 4px solid #333;\n    min-height: 30px;\n    width: 100%;\n    border-radius: 20px;\n    color: ${props => (props.gameOver ? 'red' : '#999')};\n    background: #000;\n    font-family: Pixel, Arial, Helvetica, sans-serif;\n    font-size: 0.8rem;\n`","import React from 'react';\n\nimport { StyledDisplay } from \"./styles/StyledDisplay\";\n\n// Display represents the UI\nconst Display = ({ gameOver, text }) => (\n    <StyledDisplay gameOver={gameOver}>{text}</StyledDisplay>\n)\n\nexport default Display;","import styled from 'styled-components';\n\nexport const StyledStartButton = styled.div`\n    box-sizing: border-box;\n    margin: 0 0 20px 0;\n    padding: 20px;\n    min-height: 30px;\n    width: 100%;\n    border-radius: 20px;\n    border: none;\n    color: white;\n    background: #333;\n    font-family: Pixel, Arial, Helvetica, sans-serif;\n    font-size: 1rem;\n    outline: none;\n    cursor: pointer;\n`","import React from 'react';\n\nimport { StyledStartButton } from \"./styles/StyledStartButton\";\n\n// A button that starts a new game\nconst StartButton = ({ callback }) => (\n    <StyledStartButton onClick={callback}>Start Game</StyledStartButton>\n)\n\nexport default StartButton;\n","export default __webpack_public_path__ + \"static/media/bg.d63cfd51.png\";","import styled from 'styled-components';\n\nimport bgImage from '../../img/bg.png';\n\nexport const StyledTetrisWrapper = styled.div`\n    width: 100vw;\n    height: 100vh;\n\n    background: url(${bgImage}) #000;\n    background-size: cover;\n    overflow: hidden;\n`\n\nexport const StyledTetris = styled.div`\n    display: flex;\n    align-items: flex-start;\n    padding: 40px;\n    margin: 0 auto;\n    max-width: 900px;\n\n    aside {\n        width: 100%;\n        max-width: 200px;\n        display: block;\n        padding: 0 20px;\n    }\n`","import { useState, useEffect } from \"react\";\n\nimport { createStage } from \"../gameHelpers\";\n\nexport const useStage = (player, resetPlayer) => {\n    const [stage, setStage] = useState(createStage());\n    // used to count number of cleared rows (used to compute score)\n    const [rowsCleared, setRowsCleared] = useState(0);\n\n    // useEffect is used to allow you to make changes due to side effects\n    // basically, hooks try to avoid side effects, but it isn't quite possible\n    // to eliminate them\n    // useEffect takes a callback and a list of dependancies\n    // if you omit the dependancies, this callback will fire after every render\n    // otherwise, it will fire after a render IF a dependancy changes\n    useEffect(() => {\n        setRowsCleared(0);\n\n        // this function clears out complete rows\n        const sweepRows = newStage => \n            // we use the reduce method\n            newStage.reduce((acc, row) => {\n                // a row in the stage is filled if all values are greater than 0\n                // so we search the row for 0\n                // if there are no 0s, clear the cell\n                if(row.findIndex(cell => cell[0] === 0) === -1) {\n                    // also increment the number of rows we've cleared\n                    setRowsCleared(prev => prev + 1);\n                    // here we create a new, empty row\n                    // which we use unshift to add it to the top of the stage\n                    acc.unshift(new Array(newStage[0].length).fill([0, 'clear']));\n                    return acc;\n                }\n                // if the row isn't filled, just return the current row\n                acc.push(row);\n                return acc;\n        }, [])\n\n        const updateStage = prevStage => {\n            // first we clear the stage so we can rewrite new data to it\n            const newStage = prevStage.map(row =>\n                // if the cell is marked as clear, we need to clear it\n                // this is done by putting 0, the 'no tetromino' marker\n                // otherwise, just replace it with the same cell value\n                row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell))\n            );\n\n            // then we draw the tetromino\n            // player basically refers to the current falling game piece\n            // so this splices in the current falling tetrimino into the grid\n            // in the appropriate position\n            player.tetromino.forEach((row, y) => {\n                row.forEach((value, x) => {\n                    // we skip values that are 0, which are blank\n                    // values in the tetromino\n                    if(value !== 0) {\n                        newStage[y + player.pos.y][x + player.pos.x] = [\n                            value,\n                            `${player.collided ? 'merged' : 'clear'}`\n                        ]\n                    }\n                });\n            });\n\n            // do collision detection\n            // if the current falling piece collided with something, \n            // we should stop moving the current piece\n            // and bring a new one to the top of the play field\n            if (player.collided) {\n                resetPlayer();\n                // additionally, now would be the time where we would check if\n                // we need to clear rows\n                return sweepRows(newStage);\n            }\n\n            return newStage;\n        }\n\n        // call the stage setter using the above instructions\n        setStage(prev => updateStage(prev))\n    }, [player, player.collided]);\n\n    // this hook will allow us to both read and alter the stage state\n    // so return both the getter and the setter\n    return [stage, setStage, rowsCleared];\n}\n","import { useState, useEffect, useCallback } from 'react';\n\nexport const useGameStatus = rowsCleared => {\n    const [score, setScore] = useState(0);\n    // this is used to track how many TOTAL rows the player has cleared\n    const [rows, setRows] = useState(0);\n    const [level, setLevel] = useState(0);\n\n    // the number of points you get for clearing lines\n    // the more lines you clear at once, the larger the reward\n    // these are the values used in the OG tetris game\n    const linePoints = [40, 100, 300, 1200];\n\n    // this will recalculate the score\n    // this function is fired whenever the level,\n    // the line points, or the number of cleared rows changes\n    // so it won't fire on every render, which is good for efficiency\n    const calcScore = useCallback(() => {\n        // check if we've actually cleared any rows\n        if (rowsCleared > 0) {\n            // we use both the rows cleared and the current level to calculate \n            // this is the formula used in OG tetris\n            setScore(prev => prev + linePoints[rowsCleared-1] * (level + 1));\n            setRows(prev => prev + rowsCleared);\n        }\n    }, [level, linePoints, rowsCleared])\n\n    // an effect that should run whenever the score changes\n    useEffect(() => {\n        calcScore();\n    }, [calcScore, rowsCleared, score]);\n\n    return [score, setScore, rows, setRows, level, setLevel];\n}","import React, { useState } from 'react';\n\n// components\nimport { createStage, checkCollision } from '../gameHelpers';\nimport Stage from './Stage';\nimport Display from './Display';\nimport StartButton from \"./StartButton\";\n// styling\nimport { StyledTetris, StyledTetrisWrapper } from \"./styles/StyledTetris\";\n\n// custom hooks\nimport { usePlayer } from \"../hooks/usePlayer\";\nimport { useStage } from \"../hooks/useStage\";\nimport { useInterval } from \"../hooks/useInterval\";\nimport { useGameStatus } from \"../hooks/useGameStatus\";\n\nconst Tetris = ({ type }) => {\n    // a hook used to alter speed the tetromino drops at\n    const [dropTime, setDropTime] = useState(null);\n    // a hook to get/set the gameover state\n    const [gameOver, setGameOver] = useState(false);\n\n    // get the getters/setters from our custom hooks\n    const [player, updatePlayerPos, resetPlayer, playerRotate] = usePlayer();\n    const [stage, setStage, rowsCleared] = useStage(player, resetPlayer);\n    const [score, setScore, rows, setRows, level, setLevel] = useGameStatus(\n        rowsCleared\n    );\n\n    console.log('re-rendered game');\n\n    // a callback that manages user keypresses\n    const move = ({ keyCode }) => {\n        // these controls hold during gameplay,\n        // so check if we're in game over\n        if(!gameOver) {\n            // left arrow\n            if (keyCode === 37) {\n                // move left\n                movePlayer(-1);\n            }\n            // right arrow\n            else if (keyCode === 39) {\n                // move right\n                movePlayer(1);\n            }\n            // down key\n            else if (keyCode === 40) {\n                // drop the piece\n                dropPlayer();\n            }\n            // up key\n            else if (keyCode === 38) {\n                playerRotate(stage, 1);\n            }\n        }\n    }\n\n    // update the position of the falling teromino\n    const movePlayer = dir => {\n        // only move if we aren't colliding with anything\n        if (!checkCollision(player, stage, {x: dir, y: 0})) {\n            updatePlayerPos({ x: dir, y: 0 });\n        }\n    }\n\n    const startGame = () => {\n        // reset everything\n\n        // clear the stage\n        setStage(createStage());\n        setDropTime(1000);\n        // bring a new piece to the top of the stage\n        resetPlayer();\n        // set game over to false\n        setGameOver(false);\n        // reset score\n        setScore(0);\n        setRows(0);\n        setLevel(0);\n    }\n\n    // attempt to drop the tetromino down one level\n    const drop = () => {\n        // increase level when player has cleared 10 rows\n        if (rows > (level + 1) * 10) {\n            setLevel(prev => prev + 1);\n            setDropTime(1000 / (level + 1) + 200);\n        }\n\n        // if the space below is free...\n        if(!checkCollision(player, stage, { x: 0, y: 1})) {\n            // move the piece down\n            updatePlayerPos({\n            x: 0, y: 1,\n            collided: false\n            });\n        // otherwise...\n        } else {\n            // if we have stacked pieces up to the top\n            // (that is, position 0 in the stage grid)...\n            if (player.pos.y < 1) {\n                // we are in the game over state\n                console.log(\"Game Over\");\n                setGameOver(true);\n                // we should also clear the drop time\n                setDropTime(null);\n            }\n\n            // if nothing else holds, that means this piece has\n            // been obstructed and should stop moving\n            updatePlayerPos({ x: 0, y: 0, collided: true});\n        }\n    }\n\n    // this resets the drop speed if we release the down key\n    const keyUp = ({keyCode}) => {\n        if(!gameOver) {\n            if (keyCode === 40) {\n                console.log(\"Interval On\");\n                setDropTime(1000 / (level + 1) + 200);\n            }\n        }\n    }\n\n    const dropPlayer = () => {\n        // while we manually drop pieces, we want to stop the timed drop\n        console.log(\"Interval Off\");\n        setDropTime(null);\n        drop();\n    }\n\n    // \n    useInterval(() => {\n        drop();\n    }, dropTime);\n\n    return (\n        <StyledTetrisWrapper role=\"button\" tabIndex=\"0\"\n            onKeyDown={e => move(e)}\n            onKeyUp={keyUp}\n            >\n            {/*\n                role=\"button\" is used to identify the purpose of the element\n                notably accessibility software\n                tabIndex=\"0\"\n                tab index sets the order which tabbing accesses elements\n                -1 means inaccessible through tab\n                0 is the first tabable element\n                and then any positive int is visited in order\n                (so tab item 3 comes after 0 but before 5)\n\n                Note we use the wrapper because since it is the top element,\n                it allows us to click anywhere in the screen to capture input\n                rather than a specific element\n            */}\n            <StyledTetris>\n                <Stage stage={stage}/>\n                <aside>\n                    {gameOver ? (\n                        <Display gameOver={gameOver} text=\"Game Over\" />\n                    ) : (\n                        <div>\n                            <Display text={`score: ${score}`}/>\n                            <Display text={`rows: ${rows}`} />\n                            <Display text={`level: ${level}`} />\n                        </div>\n                    )}\n                    \n                    <StartButton callback={startGame}/>\n                </aside>\n            </StyledTetris>\n        </StyledTetrisWrapper>\n    )\n}\n\nexport default Tetris;","// React Hooks should begin with 'use'\n\n// we only need useState from react\nimport { useState, useCallback, cloneElement } from 'react';\nimport { checkCollision, STAGE_WIDTH } from '../gameHelpers';\n\nimport { TETROMINOS, randomTetromino } from \"../tetrominos\";\n\nexport const usePlayer = () => {\n    // use state returns an array with two values\n    // (we use ES6 destructuring to access these two vals)\n    // the first is effectively a getter, a variable which can be used\n    //  to read state\n    // the second value is a setter function\n    // note we can set default state by passing a value to useState\n    const [player, setPlayer] = useState({\n        pos: { x: 0, y: 0},\n        tetromino: TETROMINOS[0].shape,\n        collided: false\n    });\n\n    // performs a rotation on a matrix\n    const rotate = (matrix, dir) => {\n        // make the rows into columns (transpose)\n        const rotatedTetromino = matrix.map((_, index) => \n            matrix.map(col => col[index]),\n        )\n        // then reverse each row (if applicable)\n        // this will give the rotated matrix\n        if (dir > 0) return rotatedTetromino.map(row => row.reverse());\n        return rotatedTetromino;\n    }\n\n    // performs a rotation of a tetromino\n    // and handles any collision that occurs\n    const playerRotate = (stage, dir) => {\n        // const copiedTetromino = { ...player };\n        // const copiedTetromino = JSON.parse(JSON.stringify(player));\n        const copiedTetromino = { ...player, pos: { ...player.pos}, tetromino: [...player.tetromino] }\n        copiedTetromino.tetromino = rotate(copiedTetromino.tetromino, dir);\n\n        const position = copiedTetromino.pos.x;        \n        let offset = 1;\n        // this works by \"projecting\" the current piece left and right slightly\n        // if the current piece can't fit to the left or right,\n        // we shouldn't allow for rotation\n        while(checkCollision(copiedTetromino, stage, { x: 0, y: 0})) {\n            // initially, we move the piece right by 1\n            copiedTetromino.pos.x += offset;\n\n            // basically, this routine shifts the tetromino back and forth\n            // but if we are offset beyond the size of the teromino\n            // and we are still colliding with something,\n            // we can't rotate the piece in the current position\n            // because there simply isn't room.\n            offset = -(offset + (offset > 0 ? 1 : -1));\n\n            if (offset > copiedTetromino.tetromino[0].length) {\n                // rotate(copiedTetromino.tetromino, -dir);\n                // copiedTetromino.pos.x = position;\n\n                return;\n            }\n        }\n\n        setPlayer(copiedTetromino);\n    }\n\n    // a helper function that updates player position\n    // it usese the setter function generated above\n    const updatePlayerPos = ({x, y, collided}) => {\n        // pass an arrow function\n        // note that a callback is passed\n        // you can pass a callback if your new state depends on the old\n        setPlayer(prev => ({\n            ...prev,\n            pos: { x: (prev.pos.x += x), y: prev.pos.y += y},\n            collided\n        }));\n    }\n\n    // useCallback returns a memoized callback\n    // that is, the exact function generated by this hook\n    // is preserved between calls of this custom hook\n    // (all other callbacks will be recreated each hook call)\n    // because it is memoized, each unique input returns\n    // the exact same function\n    // the inputs are determined by the array given as the second arg\n    // so in this case, we just want to create this function once\n    const resetPlayer = useCallback(() => {\n        setPlayer({\n            pos: { x: STAGE_WIDTH / 2 - 2, y: 0 },\n            tetromino: randomTetromino().shape,\n            collided: false\n        })\n    }, []);\n\n    // we will import this hook into the tetris component\n    // by returning the player setter, we can then use the return\n    // value to query the player state in tetris component\n    return [player, updatePlayerPos, resetPlayer, playerRotate];\n}\n","import { useEffect, useRef } from 'react';\n\nexport function useInterval(callback, delay) {\n  const savedCallback = useRef();\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      const id = setInterval(tick, delay);\n      return () => {\n        clearInterval(id);\n      };\n    }\n  }, [delay]);\n}\n","import React from 'react';\nimport Tetris from './components/Tetris';\n\nconst App = () => (\n  <div className=\"App\">\n    <Tetris />\n  </div>\n)\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}